<!DOCTYPE html>
<html>
  <head>
    <title>From Dockerfiles to Ansible Container</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      /* body.remark-container .remark-slide-content {
        font-family: 'Droid Serif';
        font-size: 26px;
      }
      h1, h2, h3 {
        font-size: 32px;
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      } */
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# From Dockerfiles to Ansible Container
## Tomas Tomecek

---

# /me

 * Tomáš Tomeček

--

 * Hacker, developer, tinker, speaker, teacher

--

 * Contributing to *

--

 * ~~Ops~~ engineer

--

 * Red Hat

--

 * Containerization team tech lead

???

* Ask who is Ops; initiate applause

---

# Agenda

1. Dockerfile/docker-compose project

2. Transition

3. ansible-container project

4. Container-enabled Ansible roles

5. Bright future

---

# Requirements
## For development setup and deployment

* Easy to set up

  * With a single command

--

* Consistent environment for every developer

  * Containers

  * The deployment

  * Tests

--

* Development and production environment.

  * Developers want to iterate quickly.

  * Production environment needs to be rock-solid.

???

* Everyone is running the same version of webserver, database, compiler
* We also want to run run tests in a container

---

# Dockerfile/docker-compose project
## Description

* Dockerfile (= custom image) for our application.

--

* Service images from Docker Hub

--

* Deployment done with Compose file
  * Handcrafted

--

* Examples
  ```bash
  $ docker-compose build
  $ docker-compose up
  ```

---

# sample Dockerfile

```dockerfile
FROM fedora:25
RUN dnf install -y git python-pip gcc python-devel postgresql-devel redhat-rpm-config python2-pytest npm && \
    npm install -g bower

ARG USER_ID=1000
RUN useradd -o -u ${USER_ID} django && \
    mkdir -p /opt/app && \
    chown django:django /opt/app
USER django

WORKDIR /opt/app
COPY ./requirements.txt /opt/app/
RUN pip install --user -r ./requirements.txt
COPY ./requirements-devel.txt /opt/app/
RUN  pip install --user -r ./requirements-devel.txt

COPY ./install_static_data.sh /opt/app
COPY ./bower.json /opt/app
RUN ./install_static_data.sh

# the actual sources will be replaced by bind mount in development
COPY . /opt/app/
USER root
RUN chown -R django:django .
USER django

# database needs to be set up before web can start serving requests
CMD sleep 7 && exec python /opt/app/manage.py runserver -v3 0.0.0.0:8000
```

---

# sample Compose file

```yaml
web:
  build:
    dockerfile: Dockerfile
    context: .
  ports:
   - "8000:8000"
  links:
   - db
  tty: true
  environment:
   - POSTGRESQL_DATABASE=django
   - POSTGRESQL_USER=user
   - POSTGRESQL_PASSWORD=password
   - API_KEY
db:
  image: registry.access.redhat.com/rhscl/postgresql-95-rhel7
  volumes:
    - ./db:/var/lib/pgsql/data
  environment:
   - POSTGRESQL_DATABASE=django
   - POSTGRESQL_USER=user
   - POSTGRESQL_PASSWORD=password
```

---

# Dockerfile/docker-compose project
## Pros

* Wide usage.

* Satisfies (some) requirements.

* Docker Hub contains tons of images.

* Actively developed.

---

# Dockerfile/docker-compose project
## Cons

* Compose file is not powerful:

  * Can't run commands easily in containers (e.g. database migration).

  * Can't have dev/prod specific deployments within a single definition file.

  * Service readiness checks are clunky.

  * No variables.

--

* Dockerfile and Compose file are specific to Docker ecosystem.

--

* Some Docker Hub images are outdated and lack documentation.

  * Official vs. community.

--

* Shell scripts, blah.

???

* `sleep` or poll
* can't provision vm, or a rkt container -- locked in to docker platform
* Start database migration after the database is up and accepting connections.
* Content: is it secure? What's inside?
* These pros and cons might be subjective.

---

# Shell script example

--

```bash
RUN set -eux; \
	\
# this "case" statement is generated via "update.sh"
	%%ARCH-CASE%%; \
	\
	url="https://golang.org/dl/go${GOLANG_VERSION}.${goRelArch}.tar.gz"; \
	wget -O go.tgz "$url"; \
	echo "${goRelSha256} *go.tgz" | sha256sum -c -; \
	tar -C /usr/local -xzf go.tgz; \
	rm go.tgz; \
	\
	if [ "$goRelArch" = 'src' ]; then \
		echo >&2; \
		echo >&2 'error: UNIMPLEMENTED'; \
		echo >&2 'TODO install golang-any from jessie-backports for GOROOT_BOOTSTRAP (and uninstall after build)'; \
		echo >&2; \
		exit 1; \
	fi; \
	\
	export PATH="/usr/local/go/bin:$PATH"; \
	go version
```

Source: https://github.com/docker-library/golang/blob/master/Dockerfile-debian.template#L14

---

# Transition

* Good

  * We have full Ansible power.

  * We can utilize our Ansible roles.

* Bad

  * shell → Ansible (might not be as bad)

  * You may need to learn a lot.

  * Some Ansible tasks are more complex.

---

# COPY vs copy module

```dockerfile
COPY file /path/inside/image
```

vs.

```yaml
 - name: Install file
   copy:
     src: file
     dest: /path/inside/image
```

---
# COPY vs copy module

```dockerfile
COPY file /path/inside/image
RUN chmod 0644 /path/inside/image && chown app /path/inside/image
```

vs.

```yaml
 - name: Install file
   copy:
     src: file
     dest: /path/inside/image
     owner: app
     mode: 0644
```

---

# ansible-container project
## Workflow

1. `init`

2. `install`

3. `build`

4. `run`

5. `push`

6. `deploy`

---


# ansible-container project
## pros

* Utilize Ansible-Container-ready roles from Ansible Galaxy

  * Not just images, deployable units!

* Support complete lifecycle of the application.

* Use Ansible, the universal markup, to create images.

* Actively developed.


---

# ansible-container project
## cons

* Not mature yet


---

# Container-enabled Ansible roles

* Define how the Ansible role is meant to be used in container environment.

--

* https://github.com/chouseknecht/django-gulp-nginx/blob/master/container.yml
  * Orchestration metadata
  * Configuration for ansible-container

---

# container.yml

```yaml
defaults:
  POSTGRES_USER: django
  POSTGRES_PASSWORD: sesame
  POSTGRES_DB: django
  DJANGO_ROOT: /django
  DJANGO_USER: django
  DJANGO_PORT: 8080
  DJANGO_VENV: /venv
  NODE_USER: node
  NODE_HOME: /node
  NODE_ROOT: ''
  GULP_DEV_PORT: 8080
```

---

# container.yml

```yaml
services:
  django:
    from: 'centos:7'
    roles:
    - role: django-gunicorn
    environment:
      DATABASE_URL: 'pgsql://{{ POSTGRES_USER }}:{{ POSTGRES_PASSWORD }}@postgresql:5432/{{ POSTGRES_DB }}'
      DJANGO_ROOT: '{{ DJANGO_ROOT }}'
      DJANGO_VENV: '{{ DJANGO_VENV }}'
    expose:
    - '{{ DJANGO_PORT }}'
    working_dir: '{{ DJANGO_ROOT }}'
    links:
    - postgresql
    user: '{{ DJANGO_USER }}'
    command: ['/usr/bin/dumb-init', '{{ DJANGO_VENV }}/bin/gunicorn', -w, '2', -b, '0.0.0.0:{{ DJANGO_PORT }}', 'project.wsgi:application']
    entrypoint: [/usr/bin/entrypoint.sh]
    dev_overrides:
      volumes:
      - '$PWD:{{ DJANGO_ROOT }}'
      command: [/usr/bin/dumb-init, '{{ DJANGO_VENV }}/bin/python', manage.py, runserver, '0.0.0.0:{{ DJANGO_PORT }}']
      depends_on:
```

---

# Bright future

* TBD

---

# Thank you!
## Questions?

    </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: '16:9',
        highlightLines: true
      });
    </script>
  </body>
</html>
